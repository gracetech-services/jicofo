const { xml, Element } = require('@xmpp/xml'); // Ensure Element is imported if used for instanceof checks
const MediaType = require('../../../common/conference/source/mediaType');
const EndpointSourceSet = require('../../../common/conference/source/endpointSourceSet');
const { IceUdpTransport, JINGLE_ICE_UDP_TRANSPORT_NS } = require('../../../common/xmpp/jingle/iceUdpTransport'); // JINGLE_DTLS_SRTP_NS not directly used here but good to have if parsing fingerprints more deeply

const COLIBRI2_CONFERENCE_XMLNS = 'urn:xmpp:colibri2:conference';
const COLIBRI2_ERRORS_XMLNS = 'urn:xmpp:colibri2:errors';

/**
 * Builds a Colibri2 <conference-modify> IQ.
 */
function buildConferenceModifyIq(bridgeJid, localJid, meetingId, conferenceName, endpoints = [], options = {}) {
    const conferenceChildren = [];
    endpoints.forEach(ep => {
        const endpointAttrs = { id: ep.id };
        if (ep.create !== undefined) endpointAttrs.create = ep.create.toString();
        if (ep.expire !== undefined) endpointAttrs.expire = ep.expire.toString();
        if (ep.statsId) endpointAttrs['stats-id'] = ep.statsId;
        if (ep.displayName) endpointAttrs['display-name'] = ep.displayName;

        const endpointChildren = [];
        if (ep.transport) endpointChildren.push(ep.transport);
        if (ep.sources) endpointChildren.push(ep.sources);
        if (ep.media && ep.media.length > 0) endpointChildren.push(...ep.media);
        if (ep.sctpConnection) endpointChildren.push(ep.sctpConnection);
        if (ep.initialLastN !== undefined && ep.initialLastN !== null) {
            endpointChildren.push(xml('initial-last-n', { xmlns: COLIBRI2_CONFERENCE_XMLNS }, ep.initialLastN.toString()));
        }
        conferenceChildren.push(xml('endpoint', endpointAttrs, ...endpointChildren));
    });

    if (options.rtpLevelRelayType) {
        conferenceChildren.push(xml('rtp-level-relay', { type: options.rtpLevelRelayType }));
    }

    const conferenceAttrs = {
        xmlns: COLIBRI2_CONFERENCE_XMLNS,
        'meeting-id': meetingId,
        name: conferenceName
    };
    if (options.create !== undefined) conferenceAttrs.create = options.create.toString();
    if (options.expire !== undefined) conferenceAttrs.expire = options.expire.toString();

    return xml('iq',
        { to: bridgeJid, from: localJid, type: 'set' }, // ID auto-generated by @xmpp/client iqCaller
        xml('conference', conferenceAttrs, ...conferenceChildren)
    );
}

/**
 * Builds an <endpoint> element for media allocation.
 */
function buildEndpointForMediaAllocation(endpointId, params = {}) {
    const {
        requestAudio = true,
        requestVideo = true,
        requestSctp = false,
        statsId = null,
        displayName = null,
        initialSources = null
    } = params;

    const endpointAttrs = { id: endpointId, create: 'true' };
    if (statsId) endpointAttrs['stats-id'] = statsId;
    if (displayName) endpointAttrs['display-name'] = displayName;

    const endpointChildren = [];
    if (requestAudio) endpointChildren.push(xml('media', { type: MediaType.AUDIO }));
    if (requestVideo) endpointChildren.push(xml('media', { type: MediaType.VIDEO }));
    // Colibri2 sctp-connection is child of <endpoint>, not <transport> like Jingle's <sctp-port>
    if (requestSctp) endpointChildren.push(xml('sctp-connection', {xmlns: COLIBRI2_CONFERENCE_XMLNS}));

    if (initialSources instanceof EndpointSourceSet && !initialSources.isEmpty()) {
        const colibriSourcesElement = initialSources.toColibriSourcesElement(endpointId);
        if (colibriSourcesElement) endpointChildren.push(colibriSourcesElement);
    }

    return xml('endpoint', endpointAttrs, ...endpointChildren);
}

/**
 * Parses a successful <iq type='result'> response to a <conference-modify> request.
 */
function parseConferenceModifyResponse(resultIq, expectedEndpointId) {
    if (!resultIq || resultIq.attrs.type !== 'result') {
        throw new Error('parseConferenceModifyResponse: Not a result IQ or IQ is null.');
    }
    const conferenceElement = resultIq.getChild('conference', COLIBRI2_CONFERENCE_XMLNS);
    if (!conferenceElement) throw new Error('parseConferenceModifyResponse: No <conference> element in Colibri2 response.');

    const conferenceId = conferenceElement.attrs.id;
    if (!conferenceId) throw new Error('parseConferenceModifyResponse: Colibri2 <conference> element missing "id" attribute.');

    let endpointTransport = null;
    let endpointFeedbackSources = EndpointSourceSet.EMPTY; // Default to empty
    let endpointSctpPort = null;

    const endpointElement = conferenceElement.getChildren('endpoint').find(ep => ep.attrs.id === expectedEndpointId);

    if (endpointElement) {
        const transportElement = endpointElement.getChild('transport', JINGLE_ICE_UDP_TRANSPORT_NS);
        if (transportElement) {
            try {
                endpointTransport = IceUdpTransport.fromXmlElement(transportElement);
            } catch (e) {
                 console.warn(`parseConferenceModifyResponse: Failed to parse <transport> for endpoint ${expectedEndpointId}: ${e.message}`);
                 endpointTransport = null; // Or rethrow if critical
            }
        }

        const sourcesElement = endpointElement.getChild('sources', COLIBRI2_CONFERENCE_XMLNS);
        if (sourcesElement) {
            try {
                // EndpointSourceSet.fromColibriSourcesElement will call Source.fromPacketExtension.
                // Source.fromPacketExtension will throw if mediaType cannot be determined from context (null)
                // or from sourceEl.attrs.media. This is the desired strictness.
                endpointFeedbackSources = EndpointSourceSet.fromColibriSourcesElement(sourcesElement);
            } catch (e) {
                console.warn(
                    `parseConferenceModifyResponse: Could not parse feedback sources for endpoint ${expectedEndpointId}: ${e.message}. ` +
                    `This often means <source> elements in the response are missing a 'media' attribute. ` +
                    `XML: ${sourcesElement.toString()}`
                );
                // Keep endpointFeedbackSources as EndpointSourceSet.EMPTY
            }
        }

        const sctpConnectionElement = endpointElement.getChild('sctp-connection', COLIBRI2_CONFERENCE_XMLNS);
        if (sctpConnectionElement && sctpConnectionElement.attrs.port) {
            endpointSctpPort = parseInt(sctpConnectionElement.attrs.port, 10);
            if (isNaN(endpointSctpPort)) endpointSctpPort = null; // Ensure it's a number or null
        }
    } else {
        console.warn(`parseConferenceModifyResponse: Response for conference ${conferenceId} did not contain details for expected endpoint ${expectedEndpointId}`);
    }
    return { conferenceId, endpointTransport, endpointFeedbackSources, endpointSctpPort };
}

/**
 * Parses a Colibri2 error IQ.
 */
function parseColibriError(errorIq) {
    const errorElement = errorIq.getChild('error');
    if (!errorElement) return { condition: 'unknown', text: 'Malformed error IQ', colibri2Reason: null, originalErrorStanza: errorIq };

    let condition = null;
    let text = null;
    errorElement.children.forEach(child => {
        if (typeof child === 'string') return; // Ignore text nodes directly under <error>
        if (child.name === 'text' && child.attrs.xmlns === 'urn:ietf:params:xml:ns:xmpp-stanzas') {
            text = child.getText();
        } else if (child.attrs.xmlns === 'urn:ietf:params:xml:ns:xmpp-stanzas') {
            condition = child.name;
        }
    });

    const colibri2ErrorElement = errorElement.getChild('colibri2-error', COLIBRI2_ERRORS_XMLNS);
    const colibri2Reason = colibri2ErrorElement?.attrs.reason || null;

    return { condition, text, colibri2Reason, originalErrorStanza: errorIq };
}

/**
 * Builds an <endpoint> element for expiring an endpoint.
 */
function buildEndpointForExpiration(endpointId) {
    return xml('endpoint', { id: endpointId, expire: 'true' });
}

/**
 * Builds an <endpoint> element for updating transport.
 */
function buildEndpointForTransportUpdate(endpointId, transportElement) {
    if (!(transportElement instanceof Element) || transportElement.name !== 'transport') { // Check if it's an @xmpp/xml Element
        throw new Error('Invalid transportElement provided for update; expected @xmpp/xml Element.');
    }
    return xml('endpoint', { id: endpointId }, transportElement.clone()); // Clone to avoid side effects
}

/**
 * Builds an <endpoint> element for updating sources.
 */
function buildEndpointForSourcesUpdate(endpointId, sources) { // sources is EndpointSourceSet
    const colibriSourcesElement = sources?.toColibriSourcesElement(endpointId);
    if (!colibriSourcesElement) {
        return xml('endpoint', {id: endpointId});
    }
    return xml('endpoint', { id: endpointId }, colibriSourcesElement);
}

module.exports = {
    COLIBRI2_CONFERENCE_XMLNS,
    COLIBRI2_ERRORS_XMLNS,
    buildConferenceModifyIq,
    buildEndpointForMediaAllocation,
    parseConferenceModifyResponse,
    parseColibriError,
    buildEndpointForExpiration,
    buildEndpointForTransportUpdate,
    buildEndpointForSourcesUpdate
};
