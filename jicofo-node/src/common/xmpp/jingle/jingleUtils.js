const { xml } = require('@xmpp/xml');
const { JingleAction } = require('./jingleSession'); // Assuming JingleAction is exported there

/**
 * Creates a Jingle session-initiate IQ.
 * @param {string} fromJidStr - The 'from' JID string.
 * @param {string} toJidStr - The 'to' JID string.
 * @param {string} sid - The Jingle session ID.
 * @param {Element[]} contentElements - An array of Jingle <content> XML elements.
 * @returns {Element} The session-initiate IQ stanza.
 */
function createSessionInitiate(fromJidStr, toJidStr, sid, contentElements) {
    const jingleAttributes = {
        xmlns: 'urn:xmpp:jingle:1',
        action: JingleAction.SESSION_INITIATE,
        initiator: fromJidStr, // Jicofo is typically the initiator
        sid: sid
    };

    return xml('iq',
        { type: 'set', from: fromJidStr, to: toJidStr /* id will be auto-generated by @xmpp/client */ },
        xml('jingle', jingleAttributes, ...contentElements)
    );
}

/**
 * Creates a Jingle transport-replace IQ.
 * @param {string} fromJidStr - The 'from' JID string.
 * @param {string} toJidStr - The 'to' JID string (remote participant's JID).
 * @param {string} sid - The Jingle session ID.
 * @param {Element[]} contentElements - An array of Jingle <content> XML elements with new transport info.
 * @returns {Element} The transport-replace IQ stanza.
 */
function createTransportReplace(fromJidStr, toJidStr, sid, contentElements) {
    const jingleAttributes = {
        xmlns: 'urn:xmpp:jingle:1',
        action: JingleAction.TRANSPORT_REPLACE,
        initiator: fromJidStr, // Or determine actual initiator if it can change mid-session
        sid: sid
    };

    return xml('iq',
        { type: 'set', from: fromJidStr, to: toJidStr },
        xml('jingle', jingleAttributes, ...contentElements)
    );
}

// TODO: Add other Jingle IQ construction utilities as needed, e.g., for:
// - session-accept
// - session-terminate (already partially in JingleSession.js, could be centralized)
// - source-add / source-remove (already partially in JingleSession.js)
// - transport-info
// - etc.

module.exports = {
    createSessionInitiate,
    createTransportReplace
};

/**
 * Creates an array of <payload-type> XML elements from a codec config list.
 * @param {object[]} codecList - Array of codec config objects.
 *        Each object: { id: number, name: string, clockrate: number, channels?: number, parameters?: object }
 * @returns {Element[]} Array of <payload-type> XML elements.
 */
function createPayloadTypeElements(codecList = []) {
    return codecList.map(codec => {
        const attrs = {
            id: codec.id.toString(),
            name: codec.name,
            clockrate: codec.clockrate.toString()
        };
        if (codec.channels) {
            attrs.channels = codec.channels.toString();
        }
        const paramElements = [];
        if (codec.parameters) {
            for (const [name, value] of Object.entries(codec.parameters)) {
                paramElements.push(xml('parameter', { name, value }));
            }
        }
        return xml('payload-type', attrs, ...paramElements);
    });
}

/**
 * Creates an array of <rtp-hdrext> XML elements from an hdrext config list.
 * @param {object[]} hdrextList - Array of hdrext config objects.
 *        Each object: { id: number, uri: string, attributes?: object }
 * @returns {Element[]} Array of <rtp-hdrext> XML elements.
 */
function createRtpHdrExtElements(hdrextList = []) {
    return hdrextList.map(ext => {
        const attrs = {
            id: ext.id.toString(),
            uri: ext.uri
        };
        if (ext.attributes) {
            Object.assign(attrs, ext.attributes);
        }
        return xml('rtp-hdrext', { xmlns: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0', ...attrs });
    });
}

module.exports = {
    createSessionInitiate,
    createTransportReplace,
    createPayloadTypeElements,
    createRtpHdrExtElements
};

/**
 * Helper to create a BUNDLE group extension.
 * Takes an array of <content> XML elements that are part of the bundle.
 * @param {Element[]} contentElementsInBundle - Array of Jingle <content> XML elements.
 * @returns {Element|null} The <group> XML element or null if no valid content names.
 */
function createBundleGroupExtension(contentElementsInBundle) {
    if (!contentElementsInBundle || contentElementsInBundle.length === 0) return null;

    const namedContentElements = contentElementsInBundle.map(contentEl => {
        if (!contentEl.attrs.name) {
            // console.warn('Content element in BUNDLE group is missing a name attribute:', contentEl.toString());
            return null;
        }
        return xml('content', { name: contentEl.attrs.name });
    }).filter(el => el !== null);

    if (namedContentElements.length === 0) return null;

    return xml('group', { xmlns: 'urn:xmpp:jingle:apps:grouping:0', semantics: 'BUNDLE' }, ...namedContentElements);
}

module.exports = {
    createSessionInitiate,
    createTransportReplace,
    createPayloadTypeElements,
    createRtpHdrExtElements,
    createBundleGroupExtension // Added to exports
};
